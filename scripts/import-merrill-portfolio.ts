/**
 * Import Merrill Lynch Portfolio Data
 *
 * This script:
 * 1. Creates a portfolio for the user
 * 2. Imports current holdings with cost basis
 * 3. Imports all transactions
 *
 * Usage: npx tsx scripts/import-merrill-portfolio.ts <path-to-import-data.json>
 *
 * The import data JSON should be generated by reconcile-portfolio.ts
 */

import { config } from 'dotenv';
import { resolve } from 'path';

// Load environment variables from .env.local
config({ path: resolve(process.cwd(), '.env.local') });

import fs from 'fs';
import { getDatabase } from '../src/lib/database/connection';
import { getFMPProvider } from '../src/lib/data-providers/fmp';
import { PortfolioService } from '../src/lib/portfolio/PortfolioService';
import { getDemoUserId } from '../src/lib/auth/demo-user';

interface Transaction {
  symbol: string | null;
  transactionType: 'BUY' | 'SELL' | 'DEPOSIT' | 'WITHDRAW' | 'DIVIDEND';
  quantity: number | null;
  pricePerShare: number | null;
  totalAmount: number;
  fees: number;
  transactionDate: string;
  notes: string;
}

interface CurrentHolding {
  symbol: string;
  description: string;
  quantity: number;
  costBasis: number;
  currentPrice: number;
  marketValue: number;
}

interface InitialHolding {
  symbol: string;
  quantity: number;
  estimatedCostBasis: number;
}

interface ImportDataSummary {
  totalValue: number;
  cashBalance: number;
  netDeposits: number;
  totalReturn: number;
  totalReturnPercent: number;
}

interface ImportData {
  transactions: Transaction[];
  initialHoldings: InitialHolding[];
  currentHoldings: CurrentHolding[];
  summary: ImportDataSummary;
}

function validateImportData(data: unknown): data is ImportData {
  if (!data || typeof data !== 'object') return false;
  const d = data as Record<string, unknown>;

  if (!Array.isArray(d.transactions)) return false;
  if (!Array.isArray(d.initialHoldings)) return false;
  if (!Array.isArray(d.currentHoldings)) return false;
  if (!d.summary || typeof d.summary !== 'object') return false;

  const summary = d.summary as Record<string, unknown>;
  if (typeof summary.cashBalance !== 'number') return false;
  if (typeof summary.totalValue !== 'number') return false;

  return true;
}

async function main() {
  // Get import data path from command line
  const importDataPath = process.argv[2];

  if (!importDataPath) {
    console.error('Usage: npx tsx scripts/import-merrill-portfolio.ts <path-to-import-data.json>');
    console.error('');
    console.error('Example: npx tsx scripts/import-merrill-portfolio.ts ~/Desktop/portfolio-import-data.json');
    console.error('');
    console.error('Generate the import data using: npx tsx scripts/reconcile-portfolio.ts');
    process.exit(1);
  }

  // Resolve path (handle ~ and relative paths)
  const resolvedPath = importDataPath.startsWith('~')
    ? importDataPath.replace('~', process.env.HOME || '')
    : resolve(process.cwd(), importDataPath);

  // Load and validate import data
  let importData: ImportData;
  try {
    const rawData = JSON.parse(fs.readFileSync(resolvedPath, 'utf-8'));
    if (!validateImportData(rawData)) {
      console.error('Error: Invalid import data format.');
      console.error('Expected JSON with: transactions[], initialHoldings[], currentHoldings[], summary{}');
      process.exit(1);
    }
    importData = rawData;
  } catch (error) {
    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
      console.error(`Error: File not found: ${resolvedPath}`);
    } else if (error instanceof SyntaxError) {
      console.error(`Error: Invalid JSON in file: ${resolvedPath}`);
    } else {
      console.error(`Error reading import data:`, error);
    }
    process.exit(1);
  }

  console.log('\n=== MERRILL LYNCH PORTFOLIO IMPORT ===\n');
  console.log(`Import data: ${resolvedPath}`);

  const db = getDatabase();
  const fmpProvider = getFMPProvider();
  const portfolioService = new PortfolioService(db, fmpProvider);

  // Get the demo user ID
  console.log('Getting user ID...');
  const userId = await getDemoUserId();
  console.log(`User ID: ${userId}\n`);

  // Check if user already has portfolios
  const existingPortfolios = await portfolioService.getUserPortfolios(userId);
  console.log(`Existing portfolios: ${existingPortfolios.length}`);

  let portfolioId: string;

  if (existingPortfolios.length > 0) {
    // Use existing default portfolio or first one
    const defaultPortfolio = existingPortfolios.find(p => p.isDefault) || existingPortfolios[0];
    portfolioId = defaultPortfolio.id;
    console.log(`Using existing portfolio: "${defaultPortfolio.name}" (${portfolioId})\n`);

    // Check if we should clear existing data
    const existingHoldings = await portfolioService.getHoldings(portfolioId);
    if (existingHoldings.length > 0) {
      console.log(`⚠️  Portfolio has ${existingHoldings.length} existing holdings.`);
      console.log('    Clearing existing holdings and transactions for clean import...\n');

      // Clear existing data
      await db.query('DELETE FROM portfolio_holdings WHERE portfolio_id = $1', [portfolioId]);
      await db.query('DELETE FROM portfolio_transactions WHERE portfolio_id = $1', [portfolioId]);
      await db.query('DELETE FROM portfolio_daily_performance WHERE portfolio_id = $1', [portfolioId]);
      console.log('    Cleared existing data.\n');
    }
  } else {
    // Create new portfolio
    console.log('Creating new portfolio...');
    const portfolio = await portfolioService.createPortfolio({
      userId,
      name: 'Merrill Lynch CMA',
      description: 'Imported from Merrill Lynch CMA-Edge account',
      currency: 'USD',
      isDefault: true,
    });
    portfolioId = portfolio.id;
    console.log(`Created portfolio: "${portfolio.name}" (${portfolioId})\n`);
  }

  // Build set of currently held symbols
  const currentHoldings = importData.currentHoldings;
  const currentSymbols = new Set(currentHoldings.map(h => h.symbol));
  console.log(`Current holdings: ${currentSymbols.size} symbols\n`);

  // ============================================================================
  // Step 1: Import Initial Holdings (only for stocks currently held)
  // ============================================================================
  console.log('=== STEP 1: Import Initial Holdings ===\n');

  const initialHoldings = importData.initialHoldings;

  // Filter to only stocks that are currently held and have positive cost basis
  // Skip stocks that were fully sold (not in currentHoldings) as they have $0 cost basis
  const validInitialHoldings = initialHoldings.filter(h =>
    h.quantity > 0 &&
    h.symbol !== 'TSTXX' &&
    h.estimatedCostBasis > 0 &&
    currentSymbols.has(h.symbol)
  );

  console.log(`Initial holdings to import: ${validInitialHoldings.length} (skipping ${initialHoldings.length - validInitialHoldings.length} fully sold stocks)`);

  // Create BUY transactions for initial holdings (dated before transaction history)
  const initialDate = new Date('2024-02-16'); // Day before first transaction

  for (const holding of validInitialHoldings) {
    // Use the estimated cost basis from reconciliation
    const costBasis = holding.estimatedCostBasis;
    const totalAmount = holding.quantity * costBasis;

    console.log(
      `  ${holding.symbol.padEnd(6)}: ${holding.quantity.toFixed(2)} shares @ $${costBasis.toFixed(2)} = $${totalAmount.toFixed(2)}`
    );

    try {
      await portfolioService.addTransaction({
        portfolioId,
        transactionType: 'BUY',
        assetSymbol: holding.symbol,
        quantity: holding.quantity,
        pricePerShare: costBasis,
        totalAmount,
        fees: 0,
        transactionDate: initialDate,
        notes: `Initial holding - existed before transaction history`,
        skipValidation: true,
      });
    } catch (error) {
      console.error(`  ❌ Error importing ${holding.symbol}:`, error);
    }
  }

  // Initial cash deposit - use the actual cash balance from import data summary
  const expectedCashBalance = importData.summary.cashBalance;
  const transactions = importData.transactions;

  // Calculate the net cash flow from transactions to determine initial cash
  const netCashFromTx = transactions.reduce((sum, tx) => {
    if (tx.symbol === 'TSTXX' || tx.symbol === 'TMCXX') return sum;
    // Skip transactions for fully sold stocks
    if (tx.symbol && !currentSymbols.has(tx.symbol) && (tx.transactionType === 'BUY' || tx.transactionType === 'SELL')) {
      return sum;
    }

    switch (tx.transactionType) {
      case 'DEPOSIT': return sum + tx.totalAmount;
      case 'WITHDRAW': return sum - tx.totalAmount;
      case 'DIVIDEND': return sum + tx.totalAmount;
      case 'BUY': return sum - tx.totalAmount;
      case 'SELL': return sum + tx.totalAmount;
      default: return sum;
    }
  }, 0);

  // Calculate the value of initial holdings (these are imported as BUY transactions which reduce cash)
  const initialHoldingsValue = validInitialHoldings.reduce(
    (sum, h) => sum + h.quantity * h.estimatedCostBasis,
    0
  );

  // Initial cash = Expected cash balance - net cash from transactions + initial holdings value
  // We add back initial holdings value because those BUY transactions will reduce cash
  const initialCash = expectedCashBalance - netCashFromTx + initialHoldingsValue;

  console.log(`\n  Expected final cash: $${expectedCashBalance.toFixed(2)}`);
  console.log(`  Net cash from transactions: $${netCashFromTx.toFixed(2)}`);
  console.log(`  Initial holdings value: $${initialHoldingsValue.toFixed(2)}`);
  console.log(`  Initial cash deposit: $${initialCash.toFixed(2)}`);

  if (initialCash > 0) {
    await portfolioService.addTransaction({
      portfolioId,
      transactionType: 'DEPOSIT',
      totalAmount: initialCash,
      fees: 0,
      transactionDate: initialDate,
      notes: 'Initial cash balance - existed before transaction history',
      skipValidation: true,
    });
  }

  console.log(`\n✓ Imported ${validInitialHoldings.length} initial holdings + initial cash\n`);

  // ============================================================================
  // Step 2: Import Transactions (only for currently held stocks)
  // ============================================================================
  console.log('=== STEP 2: Import Transactions ===\n');

  // Sort by date (oldest first) to maintain proper order
  transactions.sort(
    (a, b) => new Date(a.transactionDate).getTime() - new Date(b.transactionDate).getTime()
  );

  console.log(`Total transactions: ${transactions.length}`);

  let imported = 0;
  let skippedMM = 0;
  let skippedSold = 0;
  let skippedZero = 0;
  let errors = 0;

  // Group by type for progress
  const byType: Record<string, number> = {};

  for (const tx of transactions) {
    // Skip TSTXX/TMCXX (money market) transactions - they just represent cash movements
    if (tx.symbol === 'TSTXX' || tx.symbol === 'TMCXX') {
      skippedMM++;
      continue;
    }

    // Skip transactions for fully sold stocks (not in current holdings)
    if (tx.symbol && !currentSymbols.has(tx.symbol) && (tx.transactionType === 'BUY' || tx.transactionType === 'SELL')) {
      skippedSold++;
      continue;
    }

    // Skip transactions with zero amount (some dividends)
    if (tx.totalAmount === 0) {
      skippedZero++;
      continue;
    }

    try {
      await portfolioService.addTransaction({
        portfolioId,
        transactionType: tx.transactionType,
        assetSymbol: tx.symbol || undefined,
        quantity: tx.quantity || undefined,
        pricePerShare: tx.pricePerShare || undefined,
        totalAmount: tx.totalAmount,
        fees: tx.fees,
        transactionDate: new Date(tx.transactionDate),
        notes: tx.notes,
        skipValidation: true, // Skip validation for historical import
      });

      imported++;
      byType[tx.transactionType] = (byType[tx.transactionType] || 0) + 1;

      // Progress indicator every 50 transactions
      if (imported % 50 === 0) {
        console.log(`  Imported ${imported} transactions...`);
      }
    } catch (error) {
      errors++;
      console.error(`  ❌ Error importing transaction: ${tx.transactionType} ${tx.symbol || ''} ${tx.transactionDate}`, error);
    }
  }

  console.log(`\n✓ Imported ${imported} transactions`);
  console.log(`  Skipped: ${skippedMM} money market, ${skippedSold} fully sold stocks, ${skippedZero} zero amount, ${errors} errors`);
  console.log('  By type:', byType);

  // Holdings cache is automatically updated by addTransaction
  console.log('\n✓ Holdings cache automatically updated by transactions\n');

  // ============================================================================
  // Step 3: Verify Import
  // ============================================================================
  console.log('=== STEP 3: Verify Import ===\n');

  const summary = await portfolioService.getPortfolioSummary(portfolioId);
  const holdings = await portfolioService.getHoldingsWithMarketData(portfolioId);

  console.log('Portfolio Summary:');
  console.log(`  Total Equity:    $${summary.totalEquity.toLocaleString('en-US', { minimumFractionDigits: 2 })}`);
  console.log(`  Holdings Value:  $${summary.holdingsValue.toLocaleString('en-US', { minimumFractionDigits: 2 })}`);
  console.log(`  Cash Balance:    $${summary.cashBalance.toLocaleString('en-US', { minimumFractionDigits: 2 })}`);
  console.log(`  Holdings Count:  ${summary.holdingsCount}`);
  console.log(`  Day Change:      ${summary.dayChangePercent >= 0 ? '+' : ''}${summary.dayChangePercent.toFixed(2)}%`);
  console.log(`  Total Return:    ${summary.totalReturnPercent >= 0 ? '+' : ''}${summary.totalReturnPercent.toFixed(2)}%`);

  // Compare against reference values from the import data
  const referenceTotal = importData.summary.totalValue;
  const referenceCash = importData.summary.cashBalance;
  const diff = Math.abs(summary.totalEquity - referenceTotal);
  const cashDiff = Math.abs(summary.cashBalance - referenceCash);

  console.log('\nComparison to Reference:');
  console.log(`  Reference Total: $${referenceTotal.toLocaleString('en-US', { minimumFractionDigits: 2 })}`);
  console.log(`  Difference:      $${diff.toLocaleString('en-US', { minimumFractionDigits: 2 })} (${((diff / referenceTotal) * 100).toFixed(2)}%)`);
  console.log(`  Reference Cash:  $${referenceCash.toLocaleString('en-US', { minimumFractionDigits: 2 })}`);
  console.log(`  Cash Diff:       $${cashDiff.toLocaleString('en-US', { minimumFractionDigits: 2 })}`);

  console.log('\nHoldings:');
  for (const h of holdings.slice(0, 10)) {
    console.log(
      `  ${h.symbol.padEnd(6)}: ${h.quantity.toFixed(2).padStart(10)} shares @ $${h.currentPrice.toFixed(2).padStart(8)} = $${h.marketValue.toFixed(2).padStart(12)}`
    );
  }
  if (holdings.length > 10) {
    console.log(`  ... and ${holdings.length - 10} more holdings`);
  }

  console.log('\n=== IMPORT COMPLETE ===\n');
  console.log(`Portfolio ID: ${portfolioId}`);
  console.log('You can now view your portfolio in the app.');

  // Close database connection
  process.exit(0);
}

main().catch((error) => {
  console.error('Import failed:', error);
  process.exit(1);
});
